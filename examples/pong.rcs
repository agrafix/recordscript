let void = #[Void]```
undefined
```;
let ignore = #[(a) => Void, r]```
(function (a) {
  return undefined;
})
```;
let round = #[(Float) => Int, r]```
Math.round
```;
let int2float = #[(Int) => Float, r]```
(function (i) {
    return i;
})
```;
let requestAnimationFrame = #[((Float) => Void) => Void::io, r]```
(function (callback) {
   window.requestAnimationFrame(callback);
})
```;
let keyListener = #[<() => {up: Int, down: Int, left: Int, right: Int}::io>::io,]```
(function () {
    var keyState = {up: 0, left: 0, right: 0, down: 0};
    var handleDown = function (e) {
        switch (e.keyCode) {
            case 37: keyState.left = 1; break;
            case 38: keyState.up = 1; break;
            case 39: keyState.right = 1; break;
            case 40: keyState.down = 1; break;
            default: return;
        }
    };
    var handleUp = function (e) {
        switch (e.keyCode) {
            case 37: keyState.left = 0; break;
            case 38: keyState.up = 0; break;
            case 39: keyState.right = 0; break;
            case 40: keyState.down = 0; break;
            default: return;
        }
    };
    window.addEventListener('keydown', handleDown, false);
    window.addEventListener('keyup', handleUp, false);
    return function () {
        return keyState;
    };
})()
```;
let targetCanvas = #[Canvas::io]```
document.getElementById('game').getContext('2d')
```;
let setFillStyle = #[(Canvas::io, String) => Canvas::io, wr]```
(function (ctx, fillStyle) {
  ctx.fillStyle = fillStyle;
  return ctx;
})
```;
let fillRect = #[(Canvas::io, Int, Int, Int, Int) => Canvas::io, wrrrr]```
(function (ctx, x, y, width, height) {
  ctx.fillRect(x, y, width, height);
  return ctx;
})
```;
let maxW = 500;
let maxH = 500;
let ballSize = 2;
let paddleWidth = 10;
let paddleHeight = 50;
let paddleHeightHalf = round(int2float(paddleHeight) / 2.0);
let initialState = {
    x: 0, y: round(int2float(maxH) / 2.0),
    ballX: round(int2float(maxW) / 2.0),
    ballY: round(int2float(maxH) / 2.0),
    ballVX: -0.5,
    ballVY: -0.5
};
let computeNextState = (keys, tick, state) => {
    let nextX = state.x - keys.left + keys.right;
    let nextY = state.y - keys.up + keys.down;
    {...!state, x: nextX, y: nextY}
};
let draw = (ctx, state) => {
    let ctx1 = fillRect(setFillStyle(ctx, "white"), 0, 0, maxW, maxH);
    let ctx2 = fillRect(setFillStyle(ctx1, "black"), state.x, state.y + paddleHeightHalf, paddleWidth, paddleHeight);
    fillRect(ctx2, state.ballX + ballSize, state.ballY + ballSize, ballSize * 2, ballSize * 2)
};
let loop = (ctx, state) => {
    requestAnimationFrame((tick) => {
        let keys = keyListener();
        let nextState = computeNextState(keys, tick, state);
        let nextContext = draw(ctx, nextState);
        loop(nextContext, nextState)
    })
};
let main = () => {
    loop(targetCanvas, initialState)
};
main()